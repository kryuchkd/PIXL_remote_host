{"ast":null,"code":"const VersionCheck = require('./version-check');\n\nconst Regex = require('./regex');\n/**\r\n * Numeric mode encodes data from the decimal digit set (0 - 9)\r\n * (byte values 30HEX to 39HEX).\r\n * Normally, 3 data characters are represented by 10 bits.\r\n *\r\n * @type {Object}\r\n */\n\n\nexports.NUMERIC = {\n  id: 'Numeric',\n  bit: 1 << 0,\n  ccBits: [10, 12, 14]\n};\n/**\r\n * Alphanumeric mode encodes data from a set of 45 characters,\r\n * i.e. 10 numeric digits (0 - 9),\r\n *      26 alphabetic characters (A - Z),\r\n *   and 9 symbols (SP, $, %, *, +, -, ., /, :).\r\n * Normally, two input characters are represented by 11 bits.\r\n *\r\n * @type {Object}\r\n */\n\nexports.ALPHANUMERIC = {\n  id: 'Alphanumeric',\n  bit: 1 << 1,\n  ccBits: [9, 11, 13]\n};\n/**\r\n * In byte mode, data is encoded at 8 bits per character.\r\n *\r\n * @type {Object}\r\n */\n\nexports.BYTE = {\n  id: 'Byte',\n  bit: 1 << 2,\n  ccBits: [8, 16, 16]\n};\n/**\r\n * The Kanji mode efficiently encodes Kanji characters in accordance with\r\n * the Shift JIS system based on JIS X 0208.\r\n * The Shift JIS values are shifted from the JIS X 0208 values.\r\n * JIS X 0208 gives details of the shift coded representation.\r\n * Each two-byte character value is compacted to a 13-bit binary codeword.\r\n *\r\n * @type {Object}\r\n */\n\nexports.KANJI = {\n  id: 'Kanji',\n  bit: 1 << 3,\n  ccBits: [8, 10, 12]\n};\n/**\r\n * Mixed mode will contain a sequences of data in a combination of any of\r\n * the modes described above\r\n *\r\n * @type {Object}\r\n */\n\nexports.MIXED = {\n  bit: -1\n};\n/**\r\n * Returns the number of bits needed to store the data length\r\n * according to QR Code specifications.\r\n *\r\n * @param  {Mode}   mode    Data mode\r\n * @param  {Number} version QR Code version\r\n * @return {Number}         Number of bits\r\n */\n\nexports.getCharCountIndicator = function getCharCountIndicator(mode, version) {\n  if (!mode.ccBits) throw new Error('Invalid mode: ' + mode);\n\n  if (!VersionCheck.isValid(version)) {\n    throw new Error('Invalid version: ' + version);\n  }\n\n  if (version >= 1 && version < 10) return mode.ccBits[0];else if (version < 27) return mode.ccBits[1];\n  return mode.ccBits[2];\n};\n/**\r\n * Returns the most efficient mode to store the specified data\r\n *\r\n * @param  {String} dataStr Input data string\r\n * @return {Mode}           Best mode\r\n */\n\n\nexports.getBestModeForData = function getBestModeForData(dataStr) {\n  if (Regex.testNumeric(dataStr)) return exports.NUMERIC;else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;else if (Regex.testKanji(dataStr)) return exports.KANJI;else return exports.BYTE;\n};\n/**\r\n * Return mode name as string\r\n *\r\n * @param {Mode} mode Mode object\r\n * @returns {String}  Mode name\r\n */\n\n\nexports.toString = function toString(mode) {\n  if (mode && mode.id) return mode.id;\n  throw new Error('Invalid mode');\n};\n/**\r\n * Check if input param is a valid mode object\r\n *\r\n * @param   {Mode}    mode Mode object\r\n * @returns {Boolean} True if valid mode, false otherwise\r\n */\n\n\nexports.isValid = function isValid(mode) {\n  return mode && mode.bit && mode.ccBits;\n};\n/**\r\n * Get mode object from its name\r\n *\r\n * @param   {String} string Mode name\r\n * @returns {Mode}          Mode object\r\n */\n\n\nfunction fromString(string) {\n  if (typeof string !== 'string') {\n    throw new Error('Param is not a string');\n  }\n\n  const lcStr = string.toLowerCase();\n\n  switch (lcStr) {\n    case 'numeric':\n      return exports.NUMERIC;\n\n    case 'alphanumeric':\n      return exports.ALPHANUMERIC;\n\n    case 'kanji':\n      return exports.KANJI;\n\n    case 'byte':\n      return exports.BYTE;\n\n    default:\n      throw new Error('Unknown mode: ' + string);\n  }\n}\n/**\r\n * Returns mode from a value.\r\n * If value is not a valid mode, returns defaultValue\r\n *\r\n * @param  {Mode|String} value        Encoding mode\r\n * @param  {Mode}        defaultValue Fallback value\r\n * @return {Mode}                     Encoding mode\r\n */\n\n\nexports.from = function from(value, defaultValue) {\n  if (exports.isValid(value)) {\n    return value;\n  }\n\n  try {\n    return fromString(value);\n  } catch (e) {\n    return defaultValue;\n  }\n};","map":{"version":3,"names":["VersionCheck","require","Regex","exports","NUMERIC","id","bit","ccBits","ALPHANUMERIC","BYTE","KANJI","MIXED","getCharCountIndicator","mode","version","Error","isValid","getBestModeForData","dataStr","testNumeric","testAlphanumeric","testKanji","toString","fromString","string","lcStr","toLowerCase","from","value","defaultValue","e"],"sources":["C:/Users/Maddi/Documents/GitHub/PIXL/node_modules/qrcode/lib/core/mode.js"],"sourcesContent":["const VersionCheck = require('./version-check')\r\nconst Regex = require('./regex')\r\n\r\n/**\r\n * Numeric mode encodes data from the decimal digit set (0 - 9)\r\n * (byte values 30HEX to 39HEX).\r\n * Normally, 3 data characters are represented by 10 bits.\r\n *\r\n * @type {Object}\r\n */\r\nexports.NUMERIC = {\r\n  id: 'Numeric',\r\n  bit: 1 << 0,\r\n  ccBits: [10, 12, 14]\r\n}\r\n\r\n/**\r\n * Alphanumeric mode encodes data from a set of 45 characters,\r\n * i.e. 10 numeric digits (0 - 9),\r\n *      26 alphabetic characters (A - Z),\r\n *   and 9 symbols (SP, $, %, *, +, -, ., /, :).\r\n * Normally, two input characters are represented by 11 bits.\r\n *\r\n * @type {Object}\r\n */\r\nexports.ALPHANUMERIC = {\r\n  id: 'Alphanumeric',\r\n  bit: 1 << 1,\r\n  ccBits: [9, 11, 13]\r\n}\r\n\r\n/**\r\n * In byte mode, data is encoded at 8 bits per character.\r\n *\r\n * @type {Object}\r\n */\r\nexports.BYTE = {\r\n  id: 'Byte',\r\n  bit: 1 << 2,\r\n  ccBits: [8, 16, 16]\r\n}\r\n\r\n/**\r\n * The Kanji mode efficiently encodes Kanji characters in accordance with\r\n * the Shift JIS system based on JIS X 0208.\r\n * The Shift JIS values are shifted from the JIS X 0208 values.\r\n * JIS X 0208 gives details of the shift coded representation.\r\n * Each two-byte character value is compacted to a 13-bit binary codeword.\r\n *\r\n * @type {Object}\r\n */\r\nexports.KANJI = {\r\n  id: 'Kanji',\r\n  bit: 1 << 3,\r\n  ccBits: [8, 10, 12]\r\n}\r\n\r\n/**\r\n * Mixed mode will contain a sequences of data in a combination of any of\r\n * the modes described above\r\n *\r\n * @type {Object}\r\n */\r\nexports.MIXED = {\r\n  bit: -1\r\n}\r\n\r\n/**\r\n * Returns the number of bits needed to store the data length\r\n * according to QR Code specifications.\r\n *\r\n * @param  {Mode}   mode    Data mode\r\n * @param  {Number} version QR Code version\r\n * @return {Number}         Number of bits\r\n */\r\nexports.getCharCountIndicator = function getCharCountIndicator (mode, version) {\r\n  if (!mode.ccBits) throw new Error('Invalid mode: ' + mode)\r\n\r\n  if (!VersionCheck.isValid(version)) {\r\n    throw new Error('Invalid version: ' + version)\r\n  }\r\n\r\n  if (version >= 1 && version < 10) return mode.ccBits[0]\r\n  else if (version < 27) return mode.ccBits[1]\r\n  return mode.ccBits[2]\r\n}\r\n\r\n/**\r\n * Returns the most efficient mode to store the specified data\r\n *\r\n * @param  {String} dataStr Input data string\r\n * @return {Mode}           Best mode\r\n */\r\nexports.getBestModeForData = function getBestModeForData (dataStr) {\r\n  if (Regex.testNumeric(dataStr)) return exports.NUMERIC\r\n  else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC\r\n  else if (Regex.testKanji(dataStr)) return exports.KANJI\r\n  else return exports.BYTE\r\n}\r\n\r\n/**\r\n * Return mode name as string\r\n *\r\n * @param {Mode} mode Mode object\r\n * @returns {String}  Mode name\r\n */\r\nexports.toString = function toString (mode) {\r\n  if (mode && mode.id) return mode.id\r\n  throw new Error('Invalid mode')\r\n}\r\n\r\n/**\r\n * Check if input param is a valid mode object\r\n *\r\n * @param   {Mode}    mode Mode object\r\n * @returns {Boolean} True if valid mode, false otherwise\r\n */\r\nexports.isValid = function isValid (mode) {\r\n  return mode && mode.bit && mode.ccBits\r\n}\r\n\r\n/**\r\n * Get mode object from its name\r\n *\r\n * @param   {String} string Mode name\r\n * @returns {Mode}          Mode object\r\n */\r\nfunction fromString (string) {\r\n  if (typeof string !== 'string') {\r\n    throw new Error('Param is not a string')\r\n  }\r\n\r\n  const lcStr = string.toLowerCase()\r\n\r\n  switch (lcStr) {\r\n    case 'numeric':\r\n      return exports.NUMERIC\r\n    case 'alphanumeric':\r\n      return exports.ALPHANUMERIC\r\n    case 'kanji':\r\n      return exports.KANJI\r\n    case 'byte':\r\n      return exports.BYTE\r\n    default:\r\n      throw new Error('Unknown mode: ' + string)\r\n  }\r\n}\r\n\r\n/**\r\n * Returns mode from a value.\r\n * If value is not a valid mode, returns defaultValue\r\n *\r\n * @param  {Mode|String} value        Encoding mode\r\n * @param  {Mode}        defaultValue Fallback value\r\n * @return {Mode}                     Encoding mode\r\n */\r\nexports.from = function from (value, defaultValue) {\r\n  if (exports.isValid(value)) {\r\n    return value\r\n  }\r\n\r\n  try {\r\n    return fromString(value)\r\n  } catch (e) {\r\n    return defaultValue\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}