{"ast":null,"code":"/**\r\n * Data mask pattern reference\r\n * @type {Object}\r\n */\nexports.Patterns = {\n  PATTERN000: 0,\n  PATTERN001: 1,\n  PATTERN010: 2,\n  PATTERN011: 3,\n  PATTERN100: 4,\n  PATTERN101: 5,\n  PATTERN110: 6,\n  PATTERN111: 7\n};\n/**\r\n * Weighted penalty scores for the undesirable features\r\n * @type {Object}\r\n */\n\nconst PenaltyScores = {\n  N1: 3,\n  N2: 3,\n  N3: 40,\n  N4: 10\n};\n/**\r\n * Check if mask pattern value is valid\r\n *\r\n * @param  {Number}  mask    Mask pattern\r\n * @return {Boolean}         true if valid, false otherwise\r\n */\n\nexports.isValid = function isValid(mask) {\n  return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7;\n};\n/**\r\n * Returns mask pattern from a value.\r\n * If value is not valid, returns undefined\r\n *\r\n * @param  {Number|String} value        Mask pattern value\r\n * @return {Number}                     Valid mask pattern or undefined\r\n */\n\n\nexports.from = function from(value) {\n  return exports.isValid(value) ? parseInt(value, 10) : undefined;\n};\n/**\r\n* Find adjacent modules in row/column with the same color\r\n* and assign a penalty value.\r\n*\r\n* Points: N1 + i\r\n* i is the amount by which the number of adjacent modules of the same color exceeds 5\r\n*/\n\n\nexports.getPenaltyN1 = function getPenaltyN1(data) {\n  const size = data.size;\n  let points = 0;\n  let sameCountCol = 0;\n  let sameCountRow = 0;\n  let lastCol = null;\n  let lastRow = null;\n\n  for (let row = 0; row < size; row++) {\n    sameCountCol = sameCountRow = 0;\n    lastCol = lastRow = null;\n\n    for (let col = 0; col < size; col++) {\n      let module = data.get(row, col);\n\n      if (module === lastCol) {\n        sameCountCol++;\n      } else {\n        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);\n        lastCol = module;\n        sameCountCol = 1;\n      }\n\n      module = data.get(col, row);\n\n      if (module === lastRow) {\n        sameCountRow++;\n      } else {\n        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);\n        lastRow = module;\n        sameCountRow = 1;\n      }\n    }\n\n    if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);\n    if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);\n  }\n\n  return points;\n};\n/**\r\n * Find 2x2 blocks with the same color and assign a penalty value\r\n *\r\n * Points: N2 * (m - 1) * (n - 1)\r\n */\n\n\nexports.getPenaltyN2 = function getPenaltyN2(data) {\n  const size = data.size;\n  let points = 0;\n\n  for (let row = 0; row < size - 1; row++) {\n    for (let col = 0; col < size - 1; col++) {\n      const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);\n      if (last === 4 || last === 0) points++;\n    }\n  }\n\n  return points * PenaltyScores.N2;\n};\n/**\r\n * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,\r\n * preceded or followed by light area 4 modules wide\r\n *\r\n * Points: N3 * number of pattern found\r\n */\n\n\nexports.getPenaltyN3 = function getPenaltyN3(data) {\n  const size = data.size;\n  let points = 0;\n  let bitsCol = 0;\n  let bitsRow = 0;\n\n  for (let row = 0; row < size; row++) {\n    bitsCol = bitsRow = 0;\n\n    for (let col = 0; col < size; col++) {\n      bitsCol = bitsCol << 1 & 0x7FF | data.get(row, col);\n      if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++;\n      bitsRow = bitsRow << 1 & 0x7FF | data.get(col, row);\n      if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++;\n    }\n  }\n\n  return points * PenaltyScores.N3;\n};\n/**\r\n * Calculate proportion of dark modules in entire symbol\r\n *\r\n * Points: N4 * k\r\n *\r\n * k is the rating of the deviation of the proportion of dark modules\r\n * in the symbol from 50% in steps of 5%\r\n */\n\n\nexports.getPenaltyN4 = function getPenaltyN4(data) {\n  let darkCount = 0;\n  const modulesCount = data.data.length;\n\n  for (let i = 0; i < modulesCount; i++) darkCount += data.data[i];\n\n  const k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);\n  return k * PenaltyScores.N4;\n};\n/**\r\n * Return mask value at given position\r\n *\r\n * @param  {Number} maskPattern Pattern reference value\r\n * @param  {Number} i           Row\r\n * @param  {Number} j           Column\r\n * @return {Boolean}            Mask value\r\n */\n\n\nfunction getMaskAt(maskPattern, i, j) {\n  switch (maskPattern) {\n    case exports.Patterns.PATTERN000:\n      return (i + j) % 2 === 0;\n\n    case exports.Patterns.PATTERN001:\n      return i % 2 === 0;\n\n    case exports.Patterns.PATTERN010:\n      return j % 3 === 0;\n\n    case exports.Patterns.PATTERN011:\n      return (i + j) % 3 === 0;\n\n    case exports.Patterns.PATTERN100:\n      return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;\n\n    case exports.Patterns.PATTERN101:\n      return i * j % 2 + i * j % 3 === 0;\n\n    case exports.Patterns.PATTERN110:\n      return (i * j % 2 + i * j % 3) % 2 === 0;\n\n    case exports.Patterns.PATTERN111:\n      return (i * j % 3 + (i + j) % 2) % 2 === 0;\n\n    default:\n      throw new Error('bad maskPattern:' + maskPattern);\n  }\n}\n/**\r\n * Apply a mask pattern to a BitMatrix\r\n *\r\n * @param  {Number}    pattern Pattern reference number\r\n * @param  {BitMatrix} data    BitMatrix data\r\n */\n\n\nexports.applyMask = function applyMask(pattern, data) {\n  const size = data.size;\n\n  for (let col = 0; col < size; col++) {\n    for (let row = 0; row < size; row++) {\n      if (data.isReserved(row, col)) continue;\n      data.xor(row, col, getMaskAt(pattern, row, col));\n    }\n  }\n};\n/**\r\n * Returns the best mask pattern for data\r\n *\r\n * @param  {BitMatrix} data\r\n * @return {Number} Mask pattern reference number\r\n */\n\n\nexports.getBestMask = function getBestMask(data, setupFormatFunc) {\n  const numPatterns = Object.keys(exports.Patterns).length;\n  let bestPattern = 0;\n  let lowerPenalty = Infinity;\n\n  for (let p = 0; p < numPatterns; p++) {\n    setupFormatFunc(p);\n    exports.applyMask(p, data); // Calculate penalty\n\n    const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data); // Undo previously applied mask\n\n    exports.applyMask(p, data);\n\n    if (penalty < lowerPenalty) {\n      lowerPenalty = penalty;\n      bestPattern = p;\n    }\n  }\n\n  return bestPattern;\n};","map":{"version":3,"names":["exports","Patterns","PATTERN000","PATTERN001","PATTERN010","PATTERN011","PATTERN100","PATTERN101","PATTERN110","PATTERN111","PenaltyScores","N1","N2","N3","N4","isValid","mask","isNaN","from","value","parseInt","undefined","getPenaltyN1","data","size","points","sameCountCol","sameCountRow","lastCol","lastRow","row","col","module","get","getPenaltyN2","last","getPenaltyN3","bitsCol","bitsRow","getPenaltyN4","darkCount","modulesCount","length","i","k","Math","abs","ceil","getMaskAt","maskPattern","j","floor","Error","applyMask","pattern","isReserved","xor","getBestMask","setupFormatFunc","numPatterns","Object","keys","bestPattern","lowerPenalty","Infinity","p","penalty"],"sources":["C:/Users/Maddi/Documents/GitHub/PIXL/node_modules/qrcode/lib/core/mask-pattern.js"],"sourcesContent":["/**\r\n * Data mask pattern reference\r\n * @type {Object}\r\n */\r\nexports.Patterns = {\r\n  PATTERN000: 0,\r\n  PATTERN001: 1,\r\n  PATTERN010: 2,\r\n  PATTERN011: 3,\r\n  PATTERN100: 4,\r\n  PATTERN101: 5,\r\n  PATTERN110: 6,\r\n  PATTERN111: 7\r\n}\r\n\r\n/**\r\n * Weighted penalty scores for the undesirable features\r\n * @type {Object}\r\n */\r\nconst PenaltyScores = {\r\n  N1: 3,\r\n  N2: 3,\r\n  N3: 40,\r\n  N4: 10\r\n}\r\n\r\n/**\r\n * Check if mask pattern value is valid\r\n *\r\n * @param  {Number}  mask    Mask pattern\r\n * @return {Boolean}         true if valid, false otherwise\r\n */\r\nexports.isValid = function isValid (mask) {\r\n  return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7\r\n}\r\n\r\n/**\r\n * Returns mask pattern from a value.\r\n * If value is not valid, returns undefined\r\n *\r\n * @param  {Number|String} value        Mask pattern value\r\n * @return {Number}                     Valid mask pattern or undefined\r\n */\r\nexports.from = function from (value) {\r\n  return exports.isValid(value) ? parseInt(value, 10) : undefined\r\n}\r\n\r\n/**\r\n* Find adjacent modules in row/column with the same color\r\n* and assign a penalty value.\r\n*\r\n* Points: N1 + i\r\n* i is the amount by which the number of adjacent modules of the same color exceeds 5\r\n*/\r\nexports.getPenaltyN1 = function getPenaltyN1 (data) {\r\n  const size = data.size\r\n  let points = 0\r\n  let sameCountCol = 0\r\n  let sameCountRow = 0\r\n  let lastCol = null\r\n  let lastRow = null\r\n\r\n  for (let row = 0; row < size; row++) {\r\n    sameCountCol = sameCountRow = 0\r\n    lastCol = lastRow = null\r\n\r\n    for (let col = 0; col < size; col++) {\r\n      let module = data.get(row, col)\r\n      if (module === lastCol) {\r\n        sameCountCol++\r\n      } else {\r\n        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5)\r\n        lastCol = module\r\n        sameCountCol = 1\r\n      }\r\n\r\n      module = data.get(col, row)\r\n      if (module === lastRow) {\r\n        sameCountRow++\r\n      } else {\r\n        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5)\r\n        lastRow = module\r\n        sameCountRow = 1\r\n      }\r\n    }\r\n\r\n    if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5)\r\n    if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5)\r\n  }\r\n\r\n  return points\r\n}\r\n\r\n/**\r\n * Find 2x2 blocks with the same color and assign a penalty value\r\n *\r\n * Points: N2 * (m - 1) * (n - 1)\r\n */\r\nexports.getPenaltyN2 = function getPenaltyN2 (data) {\r\n  const size = data.size\r\n  let points = 0\r\n\r\n  for (let row = 0; row < size - 1; row++) {\r\n    for (let col = 0; col < size - 1; col++) {\r\n      const last = data.get(row, col) +\r\n        data.get(row, col + 1) +\r\n        data.get(row + 1, col) +\r\n        data.get(row + 1, col + 1)\r\n\r\n      if (last === 4 || last === 0) points++\r\n    }\r\n  }\r\n\r\n  return points * PenaltyScores.N2\r\n}\r\n\r\n/**\r\n * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,\r\n * preceded or followed by light area 4 modules wide\r\n *\r\n * Points: N3 * number of pattern found\r\n */\r\nexports.getPenaltyN3 = function getPenaltyN3 (data) {\r\n  const size = data.size\r\n  let points = 0\r\n  let bitsCol = 0\r\n  let bitsRow = 0\r\n\r\n  for (let row = 0; row < size; row++) {\r\n    bitsCol = bitsRow = 0\r\n    for (let col = 0; col < size; col++) {\r\n      bitsCol = ((bitsCol << 1) & 0x7FF) | data.get(row, col)\r\n      if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++\r\n\r\n      bitsRow = ((bitsRow << 1) & 0x7FF) | data.get(col, row)\r\n      if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++\r\n    }\r\n  }\r\n\r\n  return points * PenaltyScores.N3\r\n}\r\n\r\n/**\r\n * Calculate proportion of dark modules in entire symbol\r\n *\r\n * Points: N4 * k\r\n *\r\n * k is the rating of the deviation of the proportion of dark modules\r\n * in the symbol from 50% in steps of 5%\r\n */\r\nexports.getPenaltyN4 = function getPenaltyN4 (data) {\r\n  let darkCount = 0\r\n  const modulesCount = data.data.length\r\n\r\n  for (let i = 0; i < modulesCount; i++) darkCount += data.data[i]\r\n\r\n  const k = Math.abs(Math.ceil((darkCount * 100 / modulesCount) / 5) - 10)\r\n\r\n  return k * PenaltyScores.N4\r\n}\r\n\r\n/**\r\n * Return mask value at given position\r\n *\r\n * @param  {Number} maskPattern Pattern reference value\r\n * @param  {Number} i           Row\r\n * @param  {Number} j           Column\r\n * @return {Boolean}            Mask value\r\n */\r\nfunction getMaskAt (maskPattern, i, j) {\r\n  switch (maskPattern) {\r\n    case exports.Patterns.PATTERN000: return (i + j) % 2 === 0\r\n    case exports.Patterns.PATTERN001: return i % 2 === 0\r\n    case exports.Patterns.PATTERN010: return j % 3 === 0\r\n    case exports.Patterns.PATTERN011: return (i + j) % 3 === 0\r\n    case exports.Patterns.PATTERN100: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0\r\n    case exports.Patterns.PATTERN101: return (i * j) % 2 + (i * j) % 3 === 0\r\n    case exports.Patterns.PATTERN110: return ((i * j) % 2 + (i * j) % 3) % 2 === 0\r\n    case exports.Patterns.PATTERN111: return ((i * j) % 3 + (i + j) % 2) % 2 === 0\r\n\r\n    default: throw new Error('bad maskPattern:' + maskPattern)\r\n  }\r\n}\r\n\r\n/**\r\n * Apply a mask pattern to a BitMatrix\r\n *\r\n * @param  {Number}    pattern Pattern reference number\r\n * @param  {BitMatrix} data    BitMatrix data\r\n */\r\nexports.applyMask = function applyMask (pattern, data) {\r\n  const size = data.size\r\n\r\n  for (let col = 0; col < size; col++) {\r\n    for (let row = 0; row < size; row++) {\r\n      if (data.isReserved(row, col)) continue\r\n      data.xor(row, col, getMaskAt(pattern, row, col))\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the best mask pattern for data\r\n *\r\n * @param  {BitMatrix} data\r\n * @return {Number} Mask pattern reference number\r\n */\r\nexports.getBestMask = function getBestMask (data, setupFormatFunc) {\r\n  const numPatterns = Object.keys(exports.Patterns).length\r\n  let bestPattern = 0\r\n  let lowerPenalty = Infinity\r\n\r\n  for (let p = 0; p < numPatterns; p++) {\r\n    setupFormatFunc(p)\r\n    exports.applyMask(p, data)\r\n\r\n    // Calculate penalty\r\n    const penalty =\r\n      exports.getPenaltyN1(data) +\r\n      exports.getPenaltyN2(data) +\r\n      exports.getPenaltyN3(data) +\r\n      exports.getPenaltyN4(data)\r\n\r\n    // Undo previously applied mask\r\n    exports.applyMask(p, data)\r\n\r\n    if (penalty < lowerPenalty) {\r\n      lowerPenalty = penalty\r\n      bestPattern = p\r\n    }\r\n  }\r\n\r\n  return bestPattern\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}